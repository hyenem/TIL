* Arrays.sort() : 버블정렬
* Collections.sort() : 머지소트(병합정렬)

## 검색
* 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
* 목적하는 탐색 키를 가진 항목을 찾는 것
    * 탐색 키 : 자료를 구별하여 인식할 수 있는 키
* 검색의 종류
    * 순차 검색
    * 이진 검색
    * 인덱싱

### 순차 검색
* 일렬로 되어 있는 자료를 순서대로 검색하는 방법
    * 가장 간단하고 직관적인 검색 방법
    * 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
    * 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행 시간이 급격히 증가하여 비효율적임
* 2가지 경우
    * 정렬되어 있지 않은 경우
    * 정렬되어 있는 경우
* 검색 과정
    * 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
    * 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
    * 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패

    * 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정하자.
    * 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료한다.
    * 정렬되어있는 경우 정렬되지 않은 경우와 빅오는 같지만 평균 비교 횟수가 반으로 줄어든다. 더 효율적인 것을 구현할 수 있다.

* 이진 검색 : 시간복잡도(logn)
    * 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    * 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함.

### 셀렉션 알고리즘
* 저장되어 있는 자료로부터 k번쨰로 큰 혹은 작은 원소를 찾는 방법
* 최댓값, 최솟값 혹은 중간값을 찾는 알고리즘


### 선택 정렬
* 주어진 자료 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
* 시간 복잡도 O(n^2)

### 카운팅 정렬
* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
* 제한사항
    * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    * 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트 배열을 사용하기 때문이다.
    * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.
* 시간 복잡도: O(n+k) (n: 배열의 길이, k는 정수의 최대값)
* 장점 : 안정정렬(같은 숫자가 두개 있을때 기존 객체의 배열 순서가 유지되도록)
* {1, 2, 1억} 이런 경우는 메모리 손해임