
# JAVA 기본

## 프로그램과 운영체제
### 프로그램
* 컴퓨터가 특정 작업을 수행하도록 지시하는 일련의 명령어들의 집합(작업 지침서)
* 컴퓨터가 이해할 수 있는 형태(기계어)로 변환되어 실행됨
* 명령은 CPU에서 실행됨
* ex) 응용 프로그램, 운영체제

### 운영체제
* 시스템 하드웨어 관리할 뿐 아니라
* 응용 프로그램 실행을 위한 하드웨어 추상화 플렛폼과 공통 시스템 서비스(프로세스 관리, 메모리 관리, 파일 시스템 관리 등)를 제공하는 시스템 소프트웨어
    * 하드웨어 추상화 플렛폼 : 제각기 다른 키보드를 사용하는데 컴퓨터가 키보드로 인식할 수 있다. 그게 키보드라는 하드웨어가 추상화 되어 있는 것.

## 컴퓨터 자료 표현
* 비트(Bit) : Binary Digit, 0 또는 1의 값만 가질 수 있음. 전기가 흐르면 1, 끊어지면 0. 두 개의 값 밖에 표현하지 못한다는 한계가 있음.
* 바이트(Byte) : 8개의 비트로 구성된 정보 단위. 컴퓨터 메모리의 기본 단위 -> 256가지의 값을 표현할 수 있음.
    * 32비트 컴퓨터는 메모리를 4GB밖에 받아드리지 못함. 주소를 32bit개 받아드릴 수 있다는 말임.
* 2진수(Binary) :  두 가지 상태(0과 1)만을 이용하는 수체계
    * 맥락에 따라서 여러가지로 해석할 수 있다
        -> 맨 앞의 수가 부호를 판단할수도, 0~255, -127~128

## 자바 가상 머신
* 자바 바이트코드를 실행할 수 있는 주체
* 바이트 코드: 소스코드와 기계어 사이의 중간 단계
* 보통은 소스코드가 바로 기계어로 변환되는데 바이트코드는 java만의 독특한 경우임
* 바이트 코드의 목적은 여러 플렛폼에서 동시에 돌아갈 수 있도록함(플렛폼 독립적).
* 바이트 코드를 JVM으로 기계어로 번역하는데, 이 속도가 매우 빠름. 그러니까 일단 한 번 바이트 코드를 만들어 놓으면 오랜 컴파일 시간을 매번 할애할 필요 없이 JVM으로만 빠르게 기계어로 번역하면 되는 것임.
* JVM 자체는 플렛폼 종속적임.

* 예시
    javac Hello.java -> 컴파일
    java Hello -> JVM

## 메인 메서드
* 자바 애플리케이션의 시작점
* main() 메서드가 없다면 절대로 실행될 수 없음

## 주석
* 컴퓨터는 모르고 사람만 보는 줄
* //내용 : 한 줄 주석, 해당 기호가 있는 위치부터 그 줄 끝까지 주석처리
* /* 내용 */ : 여러줄 주석, 해당 범위의 내용 주석처리
* /** 내용 */ : 문서화 주석, Documentation API를 위한 주석처리

## 출력문
* print 메서드 : 값을 출력한 후 줄바꿈 하지 않음, 필요시 `\n`(줄바꿈)을 사용
* println : 값을 출력한 후 줄바꿈을 함
* `printf` : 포멧 지정자(%로 시작)을 사용하여 형식을 지정해 데이터를 출력. 줄바꿈을 자동으로 하지 않음
    * `%d` 정수
    * `%f` 실수
    * `%s` 문자열
    * `%c` 문자

* `\`를 출력하고 싶으면 두 개 쓰기 `\\`
* `"`를 출력하고 싶으면 `\*`

## 변수
### 정의
* 변수 데이터 저장을 위해 메모리의 특정 위치를 가르키는 이름
* 변수를 선언하면 저장할 데이터 타임에 따라 적정한 크기의 메모리 공간을 확보
* 변수를 통해 메뫃리 상의 데이터를 읽고 쓸 수 있음
* `=`을 통해서 CPU에 연산 명령

### 변수의 이름 규칙
* 대소문자 구분
* 공백 허용되지 않음
* 숫자로 시작 불가
* 특수문자는 $와 _만 사용할 수 있음
* 예약어(자바 문법에서 사용하고 있는 단어들)은 사용 불가
* camelCase 사용 권장, 영문 사용 권장

## 자료형
* 자바의 특징 중 하나가 데이터 타입을 항상 지정해줘야 한다는 것.
### 기본 자료형 : 변수 자체에 값이 직접 저장됨
|타입|세부타입|데이터형|크기|기본값|값의 범위|
|----|-----|-----|-----|-----|-----|
|논리형|boolan||fase|true/false|
|문자형|char|2byte|널문자(\u0000)|0~35535|
|정수형|byte|1byte|0|-128~127|
|정수형|short|2byte|0||
|정수형|int|4byte|0||
|정수형|long|8byte|0L|| 
|실수형|float|4byte|0.0f||
|실수형|double|8byte|0.0d||

### 참조 자료형 : 변수에 참조(레퍼런스, 주소)를 저장, 기본값은 null(아무것도 참조하지 않음) 

## 형 변환
* 자동(묵시적, 암묵적) 형 변환이 가능한 방향
* byte -> short -> int -> long -> float -> double
*    -> char 

* 묵시적 형변환 : 작은 집에서 큰 집으로 이사간다
    * 범위가 넓은 데이터 형에 좁은 데이터 형을 대입
    * 아무런 이상 없이 자연스럽게 가능함
    * ex) byte b = 100; int i = b;

* 명시적 형변환 : 큰 집에서 작은 집으로 이사간다
    * 범위가 좁은 데이터 형에 넓은 데이터 형을 대입하는 것
    * 형 변환 연산자를 사용 -> (타입)갑
    * ex) int i = 100; b = (byte) i;

## 연산자
### 증감 연산자 ++, --
* 피연산자의 값을 1 증가, 감소시킨다.
* 전위형 ++i, --i : 값을 먼저 증감시킨 후 사용
* 후위형 i++, i-- : 값을 사용한 후 증감

### 단항 연산자

### 산술 연산자
* 정수와 정수의 연산 => 정수
    * `5/3 => 1` 버림 처리 되고 몫만 나옴.
* 정수와 실수의 연산 => 실수
* 연산을 할 때 우선 데이터 형을 범위가 큰 쪽으로 통일한 뒤에 연산(다른 데이터 형의 경우 암묵적 형변환이 일어남)

### 비교 연산자
* 대소 비교 연산 : `>` `>=` `<=` `<`
* 동등 비교 연산 : `==` `!=`
    * `==` 주의할 점 : `참조 자료형`을 비교할 때에는 주소 비교를 함
    * String 변수 비교는 `equals()`를 사용
### 논리 연산자
### 삼항 연산자
    * `조건식? 식1: 식2`
    * 조건식이 참일 경우 식1 수행
    * 조건식이 거짓일 경우 식2 수행
### 복합 대입 연산자
    * `+=`, `-=`, `*=`, `/=`


## 제어문
* 제어문 : 프로그램의 흐름을 제어하는 문법 요소
### `if` 문
* 실행할 문장이 하나라면 중괄호 생략 가능
### `switch`문
* 조건식 안부터 시작해서 `break`가 나올 때 까지 순서대로 쭉 진행됨!
### do-while 문
* 블록 내용을 먼저 수행한 후 조건식 판다. 최소 한 번은 수행
## 점프 제어문
* break 문 : 가장 가까운 반복문을 빠져나감, 중첩 반복문 구조에서 반복문에 이름(라벨)을 붙여 한 번에 빠져나올 수 있음.
* continue 문 : 현재의 반복의 나머지 부분을 건너뛰고 다음 반복으로 감
* return 문 : 현재 메서드를 종료함