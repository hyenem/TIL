# JVM 메모리 구조

## JVM 메모리 구조란?
* Java언어는 메모리 관리를 개발자가 하지 않음 : 메모리 관리는 JVM에 의해 자동으로 처리
* GC(Garbage Collection) : JVM은 가비지 컬렉터를 통해 자동으로 메모리를 관리, 사용되지 않는 객체를 메모리에서 해제

* JVM 메모리 영역은 크게 메서드 영역, 힙 영역, 스택 영역으로 나뉨
    * 메서드 영역 : 클래스(또는 인터페이스)(설계도)의 메서드, 필드와 같은 클래스 관련 정보 저장
    * 힙 영역 : 모든 객체(인스턴스의 상태, 변수)와 배열, 문자열 상수를 저장
    * 스택 영역 : 메서드 호출 시마다 프레임 생성. 프레임 안에는 로컬 변수, 메서드 호출 정보(메서드가 종료되면 어디로 돌아가야 하는지 같은 것들), 중간 연산 결과 등이 저장. 메서드가 종료되면 해당 프레임이 자동으로 제거됨.
        *  실행시키면 main을 저장, 그러고 method가 나오면 그 main의 라인을 저장한 다음에 method를 스택에 쌓고 method가 끝나면 method를 out 하고 main으로 돌아감
        * main에서 객체를 생성하면, stack에는 heap영역의 해당 인스턴스 정보의 참조값이 저장됨.

    * .java를 이크립스에서 저장하면 *.class 파일이 bin 폴더에 자동으로 저장됨.

    * 멤버변수는 기본적으로 heap안에 들어감(동적/ 객체가 만들어 질 때)
    * 그런데 static(정적)으로 선언을 하면 메소드 영역 안의 class에 저장됨.

## static 특징
* 로딩 시점 : 클래스 로딩시(설계도가 메서드 영역에 로딩 될 때)
    * cf) non-static : 객체 생성시 (new 생성자())
* 메모리상의 차이 : 클래스 당 하나의 메모리 공간만 할당
    * cf) 인스턴스 당 메모리가 별도로 할당(인스턴스 변수, 상태)
* 사용 목적 : 모든 인스턴스에 공통으로 사용되는 메서드나 변수를 정의할 때 사용
    * cf) 객체마다 개별적으로 관리되는 상태나 동작을 정의할 때 사용

* static 영역에서는 non-static 영역을 직접 접근이 불가능
    * static은 설계도를 불러오는 시점에 이미 존재
    * non-static은 객체 생성 후 생긴다(나중에)
* non-static 영역에서는 static 영역에 대한 접근 가능
* static영역 내에서는 this 사용 불가. this 는 instance에 대한 이야기임.

* 정적 초기화 블록 : 클래스가 로드될 때 한 번 실행 주로 정적변수를 초기화하는데 사용


### 사용 방법
* static : 클래스 이름으로 접근(객체 생성 필요 x) - Class.attribute
    * cf) 객체 생성 후 접근 - Instance.atrribute
    

* class에 static을 붙이면?!?!??!?!?!?!

# 접근 제어자
## 패키지
* PC의 많은 파일을 관리하기 위해 폴더를 이용한다.
* 프로그램의 많은 클래스를 관리하기 위해서 패키지를 이용한다.

* 패키지는 클래스와 관련 있는 인터페이스들을 모아두기 위한 이름 공간.
* 패키지의 구분은 .(dot) 연산자를 이용한다.
* 패키지의 이름은 시중에 나와있는 패키지들과 구분되게 지어야 한다.
* 일반적으로 소속이나 회사의 도메인을 사용
    * com.ssafy.

## 임포트
* 다른 패키지에 있는 클래스를 사용하기 위해서는 import 과정이 필요하다.
* import를 선언할 때는 package 이름과 클래스 이름을 모두 입력하거거나 해당 패키지의 모든 클래스를 포함할 때는 '*'을 사용하기도 함.(하위 패키지까지 가져오진 않음)

## 캡슐화
* 객체의 속성과 행위를 하나로 묶고
* 실제 구현 내용 일부를 외부에 감추어 은닉한다.
* 호출, 변경 가능 여부를 조정

## 접근 제어자 (access modifier)
* 클래스, 멤버 변수, 멤버 메서드 등의 선언부에서 접근의 허용 범위를 지정하는 역할의 키워드이다.
### public, protected, (default), private
* public : 모든 위치에서 접근이 가능
* protected : 같은 패키지에서 접근이 가능, 다른 패키지 접근 불가능. 단, 다른 패키지의 클래스와 상속관계가 있을 경우 접근가능
* (default) : 같은 패키지에서만 접근이 허용. 접근제어자가 선언이 안되었을 경우 기본 적용
* private : 자신 클래스에만 접근이 허용.
* 클래스(외부) : public, default만 사용 가능

### 접근자 / 설정자
* 클래스에서 선언된 변수 중 접근제한에 의해 접근할 수 없는 변수의 경우 다른 클래스에서 접근할 수 없기 때문에 접근하기 위한 메서드를 public으로 선언하여 사용.

## 싱글턴 패턴
* 소프트웨어 디자인 패턴에서 싱글턴 패턴을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고, 최초 생성 이후에 호출된 생성자는 최초 생성자가 생성한 개체를 리턴

## 객체 배열 관리란?
* 정보 관리 시스템 ex) 학사 관리 시스템
* 캡슐화를 이용해 클래스 작성
* DB 대신 배열을 사용해 객체의 정보를 저장
* 객체의 조회, 추가, 수정, 삭제(CRUD)를 구현
* 싱글턴 패턴을 사용하여 정보 관리 일원화