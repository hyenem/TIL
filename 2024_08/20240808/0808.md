# 원형 큐
* 선형 큐의 잘못된 포화상태 오류를 해결하기 위함
## 원형 큐의 구조
* 초기 공백 상태
	* front = rear = 0
* Index의 순환
	* front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
	* 이를 위해 나머지 연산 mod를 사용함
* front 변수
	* 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
	* 공백 상태 : `front == rear;`
	* 포화 상태 : `(N+front-rear)%N == 1;`
			`front == (rear+1)%N;`
* 삽입 위치와 삭제 위치
	* 삽입 위치 : rear = (rear+1)mod n
	* 삭제 위치 : front = (front+1)mod n
	
# 우선순위 큐
## 우선순위 큐의 특성
* 우선순위를 가진 항목을 저장하는 큐
* FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.

## 우선순위 큐의 적용 분야
* 시뮬레이션 시스템
* 네트워크 트래픽 제어
* 운영체제의 테스크 스케줄링

## 우선순위 큐의 구현
* 근데 인제 배열을 이용한
	* 배열을 이용하여 자료 저장
	* 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
	* 가장 앞에 최고 우선순위 원소가 위치하게 됨
* 문제점
	* 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함
	* 이에 소요되는 시간이나 메모리 낭비가 큼
	
### 삽입 정렬
* 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성한다.
* 정렬 과정
	* 정렬할 자료를 두개의 부분집합 S와 U로 가정
		* 부분집합S : 정렬된 앞부분의 원소들
		* 부분집합U : 아직 정렬되지 않는 나머지 원소들
	* 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입한다.
	* 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 한다. 부분집합 U가 공집합이 되면 삽입 정렬이 완성된다.
* 이미 정렬된 데이터가 많고 새로 들어온 데이터가 적을 때 쓰기 좋은 정렬 알고리즘임.