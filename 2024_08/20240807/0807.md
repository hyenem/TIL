# 큐
## 큐
* 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
	* 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
* 선입선출구조(FIFO:first in first out)
	* 큐에 삽입합 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.
	* ex) 프린터기, 게임 대기열
	* 삭제되는 부분의 포인터 '머리(front, head)', 삽입되는 부분의 포인터 '꼬리(rear, tail)'을 사용함.
* Queue의 기본 연산 
	* 삽입(enQueue)
	* 삭제(deQueue)
	* createQueue() : 공백상태의 큐를 생성하는 연산(큐가 클래스로 정의되었다면 생성자임)
	* isEmpty(), isFull()
	* Qpeek() : 큐의 앞쪽에서 원소를 삭제 없이 반환하는 연산
* 큐의 연산 과정
	* 공백 큐 생성 : front = rear = -1
	* 원소 삽입 : rear ++;
	* 원소 삭제 : return queue[++front];
	
## 선형큐
* 1차원 배열을 이용한 큐
	* 큐의 크기 = 배열의 크기
	* front : 마지막으로 삭제된 인덱스
	* rear : 저장된 마지막 원소의 인덱스
* 상태 표현
	* 초기 상태 : front = rear = -1;
	* 공백 상태 : front == rear;
	* 포화 상태 : rear == (배열의 크기)-1;
* 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear==n-1 인 상태, 즉 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨
	* 해결 방법 1 : 매 연산이 이루어질 때마다 저장된 원소를 배열의 앞부분으로 모두 이동시킴
		* 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐 -> 배열 대신 linked list를 사용하면 O(1)에 작업이 가능함.
	* 해결 방법 2 : 1차원 배열을 사용하되, 논리적으로 배열은 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용
	
## 큐의 활용
* 버퍼
	* 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
	* 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미한다.
* 버퍼의 자료구조
	* 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
	* 순서대로 입력/출력/전달되어야하므로 FIFO 방식의 자료구조인 큐가 활용된다.
* 키보드 버퍼
	* 사용자가 키보드를 입력하면 키보드 입력 버퍼에 우선 저장.
	* 컴퓨터는 자기 할 일 알아서 하다가 한번씩 버퍼에서 자료를 꺼내감. (효율적인 연산을 위하여)
